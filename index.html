<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Textured Room - Final</title>
    <style>
        html, body { 
            margin: 0; 
            height: 100%; 
            overflow: hidden; 
            background: #111; 
        }
        canvas { 
            display: block; 
        }
        .hint {
            position: absolute; 
            top: 10px; 
            left: 50%; 
            transform: translateX(-50%);
            color: #ddd; 
            font-family: system-ui, sans-serif; 
            font-size: 14px; 
            text-align: center;
            background: rgba(0,0,0,0.35); 
            padding: 6px 12px; 
            border-radius: 8px; 
            user-select: none;
        }
    </style>
</head>
<body>
    <div class="hint">
        Drag = Rotate | Scroll = Zoom | Right-drag = Pan <br> 
        'R' = Reset Camera
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // 1. Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        // 2. Camera
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        const defaultPos = new THREE.Vector3(0, 1.5, 3);
        camera.position.copy(defaultPos);
        camera.lookAt(0, 1, 0);

        // 3. Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 4. OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 1, 0);
        controls.minDistance = 0.5;
        controls.maxDistance = 12;

        // === KODE DARI LANGKAH 3 DIMULAI DI SINI ===

        // 3.1 Lights
        const ambient = new THREE.AmbientLight(0xffffff, 0.4);
        const point = new THREE.PointLight(0xffffff, 1.0, 100);
        point.position.set(0, 2.4, 0);
        scene.add(ambient, point);

        // 3.2 Texture loader + fallback
        const loader = new THREE.TextureLoader();
        function makeFallback(label) {
            const c = document.createElement('canvas');
            c.width = c.height = 256;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, 256, 256);
            ctx.fillStyle = '#999';
            ctx.font = '16px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(label, 128, 130);
            return new THREE.CanvasTexture(c);
        }

        function safeLoad(path, label) {
            let tex = loader.load(
                path,
                () => { tex.needsUpdate = true; },
                undefined,
                () => { tex = makeFallback(label); }
            );
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.minFilter = THREE.LinearMipmapLinearFilter;
            tex.magFilter = THREE.LinearFilter;
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            return tex;
        }

        const floorTex = safeLoad('floor.jpg', 'floor.jpg not found');
        const wallTex = safeLoad('wall.jpg', 'wall.jpg not found');
        const ceilingTex = safeLoad('ceiling.jpg', 'ceiling.jpg not found');

        floorTex.repeat.set(2, 2);
        wallTex.repeat.set(1.5, 1);
        ceilingTex.repeat.set(1, 1);

        // 3.3 Materials (FrontSide to face interior)
        const matFloor = new THREE.MeshStandardMaterial({ map: floorTex, side: THREE.FrontSide });
        const matWall = new THREE.MeshStandardMaterial({ map: wallTex, side: THREE.FrontSide });
        const matCeiling = new THREE.MeshStandardMaterial({ map: ceilingTex, side: THREE.FrontSide });

        // 3.4 Room Geometry (viewed from inside)
        const W = 4; // width X
        const H = 3; // height Y
        const D = 6; // depth Z

        // LANTAI (FLOOR): normal +Y (rotasi -90° X)
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matFloor);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, 0, 0);
        scene.add(floor);

        // ATAP (CEILING): normal -Y (rotasi +90° X)
        const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matCeiling);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.set(0, H, 0);
        scene.add(ceiling);

        // DINDING BELAKANG (BACK WALL): z = -D/2, no rotation
        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H), matWall);
        backWall.position.set(0, H / 2, -D / 2);
        scene.add(backWall);

        // DINDING DEPAN (FRONT WALL): z = +D/2, rotasi 180° Y
        const frontWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H), matWall);
        frontWall.rotation.y = Math.PI;
        frontWall.position.set(0, H / 2, D / 2);
        scene.add(frontWall);

        // DINDING KIRI (LEFT WALL): x = -W/2, rotasi +90° Y
        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), matWall);
        leftWall.rotation.y = Math.PI / 2;
        // PERBAIKAN 1: Menggunakan W besar, bukan w kecil
        leftWall.position.set(-W / 2, H / 2, 0);
        scene.add(leftWall);

        // DINDING KANAN (RIGHT WALL): x = +W/2, rotasi -90° Y
        const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), matWall);
        // PERBAIKAN 2: Rotasi diubah menjadi negatif agar menghadap ke dalam
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.position.set(W / 2, H / 2, 0);
        scene.add(rightWall);

        // === KODE DARI LANGKAH 3 BERAKHIR DI SINI ===

        // 5. Render Loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Wajib jika enableDamping = true
            renderer.render(scene, camera);
        }
        animate();

        // 6. Responsive Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 7. Camera Reset ('R')
        window.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                camera.position.copy(defaultPos);
                controls.target.set(0, 1, 0);
                controls.update();
            }
        });
    </script>
</body>
</html>